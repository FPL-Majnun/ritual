<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ritual ‚Äî CINCI</title>
  <style>
    :root{
      /* Ritual palette */
      --correct: #7CB8FF;  /* baby blue */
      --present: #F2C14E;  /* honey/sand */
      --absent:  #8B9098;  /* cool stone gray */
      --ink:     #0B1F33;  /* dark navy */
    }

    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { max-width: 760px; margin: 0 auto; padding: 22px 16px 40px; }
    a { color: inherit; }
    .top { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .brand { font-weight: 700; letter-spacing: .2px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; background:#f3f3f3; font-size: 13px; }
    h1 { font-size: 28px; margin: 14px 0 6px; }
    p { margin: 0 0 12px; color:#333; }
    .hr { height:1px; background:#eee; margin: 16px 0 14px; }

    .board { margin: 18px auto 16px; width: min(360px, 100%); display:grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
    .cell {
      height: 54px; border: 2px solid #ddd; border-radius: 10px;
      display:flex; align-items:center; justify-content:center;
      font-size: 22px; font-weight: 700;
      user-select: none;
    }
    /* Shake animation for invalid submit */
@keyframes shake {
  0% { transform: translateX(0); }
  20% { transform: translateX(-6px); }
  40% { transform: translateX(6px); }
  60% { transform: translateX(-6px); }
  80% { transform: translateX(6px); }
  100% { transform: translateX(0); }
}
.cell.shake {
  animation: shake 220ms ease-in-out;
}
    .cell.filled { border-color: #bbb; }
    .cell.correct { background: var(--correct); border-color: var(--correct); color: var(--ink); }
    .cell.present { background: var(--present); border-color: var(--present); color: var(--ink); }
    .cell.absent  { background: var(--absent);  border-color: var(--absent);  color: #fff; }

    .keyboard { width: min(760px, 100%); margin: 12px auto 0; display:flex; flex-direction:column; gap: 8px; }
    .row { display:flex; gap: 6px; justify-content:center; flex-wrap: nowrap; }
    .key {
      border: 1px solid #ddd; border-radius: 10px; background:#fff;
      padding: 12px 10px; min-width: 34px; text-align:center;
      font-weight: 600; cursor: pointer; user-select: none;
    }
    .key:hover { border-color: #bbb; }
    .key.wide { min-width: 68px; }
    @media (max-width: 420px) {
  .wrap { padding: 16px 12px 34px; }
  .board { width: min(330px, 100%); gap: 6px; }
  .cell { height: 50px; font-size: 20px; border-radius: 9px; }
  .row { gap: 4px; }
  .key { padding: 12px 8px; min-width: 30px; border-radius: 9px; }
  .key.wide { min-width: 58px; }
}

    /* Keyboard state colors (same as tiles) */
    .key.correct { background: var(--correct); border-color: var(--correct); color: var(--ink); }
    .key.present { background: var(--present); border-color: var(--present); color: var(--ink); }
    .key.absent  { background: var(--absent);  border-color: var(--absent);  color: #fff; }

    .hint { font-size: 13px; color:#666; margin-top: 10px; min-height: 18px; text-align:center; }
    /* Toast message (Wordle-like) */
.toast {
  position: fixed;
  top: 78px;
  left: 50%;
  transform: translateX(-50%);
  background: #111;
  color: #fff;
  padding: 10px 14px;
  border-radius: 12px;
  font-weight: 600;
  font-size: 14px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 140ms ease;
  z-index: 9999;
}
.toast.show { opacity: 1; }
  </style>
    <script src="./wordlists/allowed5.js"></script>
  <script src="./wordlists/answers5.js"></script>
</head>
<body>
  <div id="toast" class="toast" aria-live="polite"></div>
  <div class="wrap">
    <div class="top">
      <div class="brand">Ritual</div>
      <div class="pill">CINCI</div>
      <div><a href="./index.html">√énapoi</a></div>
    </div>

    <h1>CINCI</h1>
    <p>Ghice»ôte cuv√¢ntul zilei √Æn 6 √ÆncercƒÉri.</p>
    <div class="hr"></div>

    <!-- Board: 6 rows x 5 cells -->
    <div class="board" aria-label="Tabla de joc">
      <!-- Row 1 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 2 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 3 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 4 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 5 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 6 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    </div>

    <div class="keyboard" aria-label="TastaturƒÉ">
      <div class="row">
        <div class="key" data-k="Q">Q</div><div class="key" data-k="W">W</div><div class="key" data-k="E">E</div><div class="key" data-k="R">R</div><div class="key" data-k="T">T</div>
        <div class="key" data-k="Y">Y</div><div class="key" data-k="U">U</div><div class="key" data-k="I">I</div><div class="key" data-k="O">O</div><div class="key" data-k="P">P</div>
      </div>
      <div class="row">
        <div class="key" data-k="A">A</div><div class="key" data-k="S">S</div><div class="key" data-k="D">D</div><div class="key" data-k="F">F</div><div class="key" data-k="G">G</div>
        <div class="key" data-k="H">H</div><div class="key" data-k="J">J</div><div class="key" data-k="K">K</div><div class="key" data-k="L">L</div>
        <div class="key" data-k="ƒÇ">ƒÇ</div><div class="key" data-k="√Ç">√Ç</div><div class="key" data-k="√é">√é</div>
      </div>
      <div class="row">
        <div class="key wide" data-k="ENTER">Enter</div>
        <div class="key" data-k="Z">Z</div><div class="key" data-k="X">X</div><div class="key" data-k="C">C</div><div class="key" data-k="V">V</div><div class="key" data-k="B">B</div>
        <div class="key" data-k="N">N</div><div class="key" data-k="M">M</div>
        <div class="key" data-k="»ò">»ò</div><div class="key" data-k="»ö">»ö</div>
        <div class="key wide" data-k="BACKSPACE">‚Üê</div>
      </div>
    </div>

    <div style="display:flex; gap:10px; justify-content:center; align-items:center; margin-top:10px;">
  <button id="shareBtn" style="border:1px solid #ddd; border-radius:10px; background:#fff; padding:10px 12px; font-weight:600; cursor:pointer;">
    CopiazƒÉ
  </button>
  <div id="msg" class="hint" style="margin:0;">ApasƒÉ tastele sau scrie de la tastaturƒÉ.</div>
</div>
  </div>

  <script src="./wordlists/answers5.js"></script>
<script src="./wordlists/allowed5.js"></script>
  <script>
    // --- CINCI (daily-only, v0 word list) ---
    const ROWS = 6;
    const COLS = 5;

    // --- Word lists (shared across CINCI / PATRU / OPT) ---
// Clean older cedilla variants (≈û/≈¢) into comma variants (»ò/»ö) and uppercase.
function cleanWord(w) {
  return (w || "")
    .toUpperCase()
    .replaceAll("≈û", "»ò")
    .replaceAll("≈¢", "»ö");
}

// HYBRID mode normalization: diacritics optional for gameplay logic.
function normChar(ch) {
  ch = cleanWord(ch);
  if (ch === "ƒÇ" || ch === "√Ç") return "A";
  if (ch === "√é") return "I";
  if (ch === "»ò") return "S";
  if (ch === "»ö") return "T";
  return ch;
}
function normWord(w) {
  return cleanWord(w).split("").map(normChar).join("");
}

// Fallback (game still works even if wordlist files fail to load)
const FALLBACK_ANSWERS_5 = [
  "CARTE","MASIV","NOROC","PIESE","SALTA",
  "MUNTE","LACUL","ROATA","LUMEA","COPAC",
  "FEREA","SOARE","NODUL","VIRUS","LINIE",
  "PUNCT","HARTA","SAREI","CINCI","ALTAR"
].map(cleanWord);

// Robust loader: supports either Array ["CARTE", ...] OR string "CARTE\nMUNTE\n..."
function loadGlobalList(globalName) {
  const v = window[globalName];

  if (Array.isArray(v)) return v.map(cleanWord).filter(Boolean);

  if (typeof v === "string") {
    return v
      .trim()
      .split(/\s+/)
      .map(cleanWord)
      .filter(Boolean);
  }

  return [];
}

// External lists (recommended)
let ANSWERS_5 = loadGlobalList("RITUAL_ANSWERS_5");
let ALLOWED_5_LIST = loadGlobalList("RITUAL_ALLOWED_5");

// Fallbacks if lists failed to load
if (!ANSWERS_5.length) ANSWERS_5 = FALLBACK_ANSWERS_5;
if (!ALLOWED_5_LIST.length) ALLOWED_5_LIST = ANSWERS_5;

// Validate guesses by normalized form (hybrid diacritics)
const ALLOWED = new Set(ALLOWED_5_LIST.map(normWord));

// Ensure answers are also guessable (after hybrid normalization)
ANSWERS_5 = ANSWERS_5.filter(w => ALLOWED.has(normWord(w)))

    const cells = Array.from(document.querySelectorAll(".cell"));
    const keyEls = Array.from(document.querySelectorAll(".key"));
    const keyByChar = new Map(keyEls.map(k => [k.getAttribute("data-k"), k]));
    const msgEl = document.getElementById("msg");

    let row = 0;
    let col = 0;
    let isOver = false;
    let result = null; // "win" | "lose" | null

    const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(""));

   // --- Daily word selection (Europe/Bucharest midnight) ---
const START_KEY = "2025-01-01"; // season start (Bucharest date key)

function bucharestDateKey(now = new Date()) {
  const parts = new Intl.DateTimeFormat("en-CA", {
    timeZone: "Europe/Bucharest",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).formatToParts(now);

  const get = (type) => parts.find(p => p.type === type)?.value || "";
  return `${get("year")}-${get("month")}-${get("day")}`;
}

function daysBetweenKeys(startKey, endKey) {
  const [sy, sm, sd] = startKey.split("-").map(Number);
  const [ey, em, ed] = endKey.split("-").map(Number);
  const startUTC = Date.UTC(sy, sm - 1, sd);
  const endUTC = Date.UTC(ey, em - 1, ed);
  const msPerDay = 24 * 60 * 60 * 1000;
  return Math.floor((endUTC - startUTC) / msPerDay);
}

const todayKey = bucharestDateKey();
const puzzleIndex = Math.max(0, daysBetweenKeys(START_KEY, todayKey));

    // --- Deterministic shuffle (stable order across users/devices) ---
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}
function mulberry32(a) {
  return function() {
    let t = (a += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function seededShuffle(arr, seedStr) {
  const seed = xmur3(seedStr)();
  const rand = mulberry32(seed);
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// Shuffle answers once, deterministically
const ANSWER_POOL = seededShuffle(ANSWERS_5, "RITUAL-CINCI-v1");
const ANSWER_RAW = ANSWER_POOL[puzzleIndex % ANSWER_POOL.length];
const ANSWER_NORM = normWord(ANSWER_RAW);
    const shareBtn = document.getElementById("shareBtn");
    // --- Save/restore (daily-only) ---
const STORAGE_KEY = `ritual_cinci_${todayKey}`;

function saveState() {
  const state = {
    todayKey,
    row,
    col,
    isOver,
    result,
    grid,
    keyState: Array.from(keyState.entries())
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function loadState() {
  // Remove any old saved days for CINCI
  for (let i = localStorage.length - 1; i >= 0; i--) {
    const k = localStorage.key(i);
    if (k && k.startsWith("ritual_cinci_") && k !== STORAGE_KEY) {
      localStorage.removeItem(k);
    }
  }

  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return false;

  try {
    const state = JSON.parse(raw);
    if (!state || state.todayKey !== todayKey) return false;

    row = state.row ?? 0;
    col = 0; // we'll recompute from the grid after restoring letters
    isOver = !!state.isOver;
    result = state.result ?? null;

    // restore grid letters
    if (Array.isArray(state.grid) && state.grid.length === ROWS) {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = (state.grid[r] && state.grid[r][c]) ? state.grid[r][c] : "";
        }
      }
      // recompute cursor position from restored grid
if (row < ROWS) {
  const isFull = grid[row].every(ch => ch !== "");
  if (isFull) {
    row = Math.min(row + 1, ROWS);
    col = 0;
  } else {
    col = grid[row].findIndex(ch => ch === "");
    if (col < 0) col = 0;
  }
} else {
  col = 0;
}
    }

    // restore keyboard states
    keyState.clear();
    if (Array.isArray(state.keyState)) {
      for (const [ch, st] of state.keyState) {
        keyState.set(ch, st);
      }
    }

    return true;
  } catch {
    return false;
  }
}

    const toastEl = document.getElementById("toast");
let toastTimer = null;

function setMsg(text) {
  msgEl.textContent = text || ""; // keep the bottom hint updated too

  if (!toastEl) return;

  // hide if empty
  if (!text) {
    toastEl.classList.remove("show");
    return;
  }

  toastEl.textContent = text;
  toastEl.classList.add("show");

  // auto-hide after 1.3s
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    toastEl.classList.remove("show");
  }, 1300);
}
    function cellIndex(r, c) { return r * COLS + c; }

    function renderLetters() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const idx = cellIndex(r, c);
          cells[idx].textContent = grid[r][c];
          cells[idx].classList.toggle("filled", grid[r][c] !== "");
        }
      }
    }
   function renderKeyboardColors() {
  keyEls.forEach(k => k.classList.remove("absent","present","correct"));
  for (const [normCh, st] of keyState.entries()) {
    applyGroup(normCh, st);
  }
}

    function addLetter(ch) {
      if (isOver) return;
      if (row >= ROWS) return;
        // Safety: if col is wrong (e.g., stuck at 5), recompute it from the grid row
  if (col >= COLS) {
    const firstEmpty = grid[row].findIndex(x => x === "");
    if (firstEmpty !== -1) col = firstEmpty;
  }
      if (col >= COLS) return;
      grid[row][col] = ch;
      col += 1;
      renderLetters();
      setMsg("");
      saveState();
    }

    function backspace() {
      if (isOver) return;
      if (row >= ROWS) return;
      if (col === 0) return;
      col -= 1;
      grid[row][col] = "";
      renderLetters();
      setMsg("");
      saveState();
    }

    function getCurrentGuess() {
      return grid[row].join("");
    }

    // Score with duplicate-letter handling
    function scoreGuess(guessNorm, answerNorm) {
      const states = Array(COLS).fill("absent");
      const ans = answerNorm.split("");
      const g = guessNorm.split("");

      // pass 1: correct
      for (let i = 0; i < COLS; i++) {
        if (g[i] === ans[i]) {
          states[i] = "correct";
          ans[i] = null;
          g[i] = null;
        }
      }
      // pass 2: present
      for (let i = 0; i < COLS; i++) {
        if (g[i] == null) continue;
        const idx = ans.indexOf(g[i]);
        if (idx !== -1) {
          states[i] = "present";
          ans[idx] = null;
        }
      }
      return states;
    }

    function paintRow(r, states) {
      for (let c = 0; c < COLS; c++) {
        const idx = cellIndex(r, c);
        cells[idx].classList.add(states[c]);
      }
    }

    // Keep keyboard coloring monotonic: correct > present > absent
    const rank = { absent: 1, present: 2, correct: 3 };
    // Key groups for HYBRID mode (color as a family)
const KEY_GROUPS = {
  A: ["A","ƒÇ","√Ç"],
  I: ["I","√é"],
  S: ["S","»ò"],
  T: ["T","»ö"]
};

function applyKeyClass(ch, st) {
  const el = keyByChar.get(ch);
  if (!el) return;
  el.classList.remove("absent","present","correct");
  el.classList.add(st);
}

function applyGroup(normCh, st) {
  const group = KEY_GROUPS[normCh] || [normCh];
  group.forEach(k => applyKeyClass(k, st));
}
    const keyState = new Map(); // char -> state

    function updateKeyboard(guessNorm, states) {
  for (let i = 0; i < guessNorm.length; i++) {
    const normCh = guessNorm[i];
    const st = states[i];

    const group = KEY_GROUPS[normCh] || [normCh];
    if (!group.some(k => keyByChar.has(k))) continue;

    const prev = keyState.get(normCh);
    if (!prev || rank[st] > rank[prev]) {
      keyState.set(normCh, st);
      applyGroup(normCh, st);
    }
  }
}

   function submitRow() {
  if (isOver) return;
  if (row >= ROWS) return;

  // If the row isn't full, block submit
  if (grid[row].some(ch => ch === "")) {
    setMsg("CompleteazƒÉ 5 litere.");
        shakeRow(row);
    return;
  }

  const guessRaw = cleanWord(getCurrentGuess());
  const guessNorm = normWord(guessRaw);

  if (!ALLOWED.has(guessNorm)) {
    setMsg("Cuv√¢nt inexistent.");
        shakeRow(row);
    return;
  }

  const states = scoreGuess(guessNorm, ANSWER_NORM);
  paintRow(row, states);
  updateKeyboard(guessNorm, states);

  // Win?
  if (guessNorm === ANSWER_NORM) {
    isOver = true;
    result = "win";
    setMsg("Bravo. Ritual fƒÉcut ‚úÖ");
    saveState();
    return;
  }
     function shakeRow(r) {
  for (let c = 0; c < COLS; c++) {
    const idx = cellIndex(r, c);
    const el = cells[idx];
    el.classList.remove("shake"); // restart animation
    // force reflow so animation re-triggers
    void el.offsetWidth;
    el.classList.add("shake");
  }
}

  // Move to next row
  row += 1;
  col = 0;

  // Lose?
  if (row >= ROWS) {
    isOver = true;
    result = "lose";
    setMsg(`Gata. Cuv√¢ntul era: ${ANSWER_RAW}`);
    saveState();
    return;
  }

  setMsg("");
  saveState();
}

    function handleInputToken(token) {
      if (!token) return;
      if (token === "ENTER") return submitRow();
      if (token === "BACKSPACE") return backspace();

      const allowed = /^[A-ZƒÇ√Ç√é»ò»ö]$/;
      if (allowed.test(token)) addLetter(token);
    }

    // On-screen keyboard clicks
    keyEls.forEach(k => {
      k.addEventListener("click", () => {
        const t = k.getAttribute("data-k");
        handleInputToken(t);
      });
    });

    // Physical keyboard
    document.addEventListener("keydown", (e) => {
  // Don‚Äôt interfere with browser shortcuts (Ctrl/‚åò/Alt combos)
  if (e.ctrlKey || e.metaKey || e.altKey) return;

  if (e.key === "Enter") {
    e.preventDefault();
    return handleInputToken("ENTER");
  }
  if (e.key === "Backspace") {
    e.preventDefault();
    return handleInputToken("BACKSPACE");
  }

  // Romanian diacritics typed directly will work; other letters are uppercased
  const ch = (e.key || "").toUpperCase();

  // Only stop default behavior if it's a valid game letter
  if (/^[A-ZƒÇ√Ç√é»ò»ö]$/.test(ch)) {
    e.preventDefault();
    return handleInputToken(ch);
  }
});
// --- Share (copy result) ---
function emojiForState(st) {
  if (st === "correct") return "üü¶";
  if (st === "present") return "üü®";
  return "‚¨õ";
}

function buildShareText() {
  const solvedRow = grid.findIndex(r => normWord(r.join("")) === ANSWER_NORM);
  const tries = solvedRow !== -1 ? `${solvedRow + 1}/6` : (isOver ? "X/6" : "-/6");

  const lines = [];
  lines.push(`Ritual ‚Äî CINCI ${todayKey} (${tries})`);

  const maxRow = isOver ? ROWS : row;
  for (let r = 0; r < maxRow; r++) {
    const guess = grid[r].join("");
    if (guess.length !== COLS) continue;
    const states = scoreGuess(normWord(guess), ANSWER_NORM);
    lines.push(states.map(emojiForState).join(""));
  }
  return lines.join("\n");
}

async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    setMsg("Copiat ‚úÖ");
  } catch {
    window.prompt("CopiazƒÉ manual:", text);
  }
}

if (shareBtn) {
  shareBtn.addEventListener("click", () => {
    copyToClipboard(buildShareText());
  });
}

  // Start (restore today's progress if it exists)
const restored = loadState();
renderLetters();

// If we restored, we need to re-apply colors.
// Easiest v0: re-score all completed rows and repaint.
if (restored) {
  for (let r = 0; r < ROWS; r++) {
    const guess = grid[r].join("");
    if (guess.length === COLS) {
      const states = scoreGuess(normWord(guess), ANSWER_NORM);
      paintRow(r, states);
      updateKeyboard(guess, states);
    }
  }
  renderKeyboardColors();
}

saveState();
  </script>
</body>
</html>
