<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ritual ‚Äî CINCI</title>
  <style>
    :root{
      /* Ritual palette */
      --correct: #7CB8FF;  /* baby blue */
      --present: #F2C14E;  /* honey/sand */
      --absent:  #8B9098;  /* cool stone gray */
      --ink:     #0B1F33;  /* dark navy */
    }

    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { max-width: 760px; margin: 0 auto; padding: 22px 16px 40px; }
    a { color: inherit; }
    .top { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .brand { font-weight: 700; letter-spacing: .2px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; background:#f3f3f3; font-size: 13px; }
    h1 { font-size: 28px; margin: 14px 0 6px; }
    p { margin: 0 0 12px; color:#333; }
    .hr { height:1px; background:#eee; margin: 16px 0 14px; }

    .board { margin: 18px auto 16px; width: min(360px, 100%); display:grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
    .cell {
      height: 54px; border: 2px solid #ddd; border-radius: 10px;
      display:flex; align-items:center; justify-content:center;
      font-size: 22px; font-weight: 700;
      user-select: none;
    }
    .cell.filled { border-color: #bbb; }
    .cell.correct { background: var(--correct); border-color: var(--correct); color: var(--ink); }
    .cell.present { background: var(--present); border-color: var(--present); color: var(--ink); }
    .cell.absent  { background: var(--absent);  border-color: var(--absent);  color: #fff; }

    .keyboard { width: min(760px, 100%); margin: 12px auto 0; display:flex; flex-direction:column; gap: 8px; }
    .row { display:flex; gap: 6px; justify-content:center; flex-wrap: nowrap; }
    .key {
      border: 1px solid #ddd; border-radius: 10px; background:#fff;
      padding: 12px 10px; min-width: 34px; text-align:center;
      font-weight: 600; cursor: pointer; user-select: none;
    }
    .key:hover { border-color: #bbb; }
    .key.wide { min-width: 68px; }
    @media (max-width: 420px) {
  .wrap { padding: 16px 12px 34px; }
  .board { width: min(330px, 100%); gap: 6px; }
  .cell { height: 50px; font-size: 20px; border-radius: 9px; }
  .row { gap: 4px; }
  .key { padding: 12px 8px; min-width: 30px; border-radius: 9px; }
  .key.wide { min-width: 58px; }
}

    /* Keyboard state colors (same as tiles) */
    .key.correct { background: var(--correct); border-color: var(--correct); color: var(--ink); }
    .key.present { background: var(--present); border-color: var(--present); color: var(--ink); }
    .key.absent  { background: var(--absent);  border-color: var(--absent);  color: #fff; }

    .hint { font-size: 13px; color:#666; margin-top: 10px; min-height: 18px; text-align:center; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">Ritual</div>
      <div class="pill">CINCI</div>
      <div><a href="./index.html">√énapoi</a></div>
    </div>

    <h1>CINCI</h1>
    <p>Ghice»ôte cuv√¢ntul zilei √Æn 6 √ÆncercƒÉri.</p>
    <div class="hr"></div>

    <!-- Board: 6 rows x 5 cells -->
    <div class="board" aria-label="Tabla de joc">
      <!-- Row 1 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 2 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 3 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 4 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 5 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 6 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    </div>

    <div class="keyboard" aria-label="TastaturƒÉ">
      <div class="row">
        <div class="key" data-k="Q">Q</div><div class="key" data-k="W">W</div><div class="key" data-k="E">E</div><div class="key" data-k="R">R</div><div class="key" data-k="T">T</div>
        <div class="key" data-k="Y">Y</div><div class="key" data-k="U">U</div><div class="key" data-k="I">I</div><div class="key" data-k="O">O</div><div class="key" data-k="P">P</div>
      </div>
      <div class="row">
        <div class="key" data-k="A">A</div><div class="key" data-k="S">S</div><div class="key" data-k="D">D</div><div class="key" data-k="F">F</div><div class="key" data-k="G">G</div>
        <div class="key" data-k="H">H</div><div class="key" data-k="J">J</div><div class="key" data-k="K">K</div><div class="key" data-k="L">L</div>
        <div class="key" data-k="ƒÇ">ƒÇ</div><div class="key" data-k="√Ç">√Ç</div><div class="key" data-k="√é">√é</div>
      </div>
      <div class="row">
        <div class="key wide" data-k="ENTER">Enter</div>
        <div class="key" data-k="Z">Z</div><div class="key" data-k="X">X</div><div class="key" data-k="C">C</div><div class="key" data-k="V">V</div><div class="key" data-k="B">B</div>
        <div class="key" data-k="N">N</div><div class="key" data-k="M">M</div>
        <div class="key" data-k="»ò">»ò</div><div class="key" data-k="»ö">»ö</div>
        <div class="key wide" data-k="BACKSPACE">‚Üê</div>
      </div>
    </div>

    <div style="display:flex; gap:10px; justify-content:center; align-items:center; margin-top:10px;">
  <button id="shareBtn" style="border:1px solid #ddd; border-radius:10px; background:#fff; padding:10px 12px; font-weight:600; cursor:pointer;">
    CopiazƒÉ
  </button>
  <div id="msg" class="hint" style="margin:0;">ApasƒÉ tastele sau scrie de la tastaturƒÉ.</div>
</div>
  </div>

  <script src="./wordlists/answers5.js"></script>
<script src="./wordlists/allowed5.js"></script>
  <script>
    // --- CINCI (daily-only, v0 word list) ---
    const ROWS = 6;
    const COLS = 5;

    // --- Word lists (shared across CINCI / PATRU / OPT) ---
// Clean older cedilla variants (≈û/≈¢) into comma variants (»ò/»ö) and uppercase.
function cleanWord(w) {
  return (w || "")
    .toUpperCase()
    .replaceAll("≈û", "»ò")
    .replaceAll("≈¢", "»ö");
}

// HYBRID mode normalization: diacritics optional for gameplay logic.
function normChar(ch) {
  ch = cleanWord(ch);
  if (ch === "ƒÇ" || ch === "√Ç") return "A";
  if (ch === "√é") return "I";
  if (ch === "»ò") return "S";
  if (ch === "»ö") return "T";
  return ch;
}
function normWord(w) {
  return cleanWord(w).split("").map(normChar).join("");
}

// Fallback (game still works even if wordlist files fail to load)
const FALLBACK_ANSWERS_5 = [
  "CARTE","MASIV","NOROC","PIESE","SALTA",
  "MUNTE","LACUL","ROATA","LUMEA","COPAC",
  "FEREA","SOARE","NODUL","VIRUS","LINIE",
  "PUNCT","HARTA","SAREI","CINCI","ALTAR"
].map(cleanWord);

// External lists (recommended):
const ANSWERS_5 =
  (Array.isArray(window.RITUAL_ANSWERS_5) && window.RITUAL_ANSWERS_5.length)
    ? window.RITUAL_ANSWERS_5.map(cleanWord)
    : FALLBACK_ANSWERS_5;

const ALLOWED_5_LIST =
  (Array.isArray(window.RITUAL_ALLOWED_5) && window.RITUAL_ALLOWED_5.length)
    ? window.RITUAL_ALLOWED_5.map(cleanWord)
    : ANSWERS_5;

// Validate guesses by normalized form (hybrid diacritics)
const ALLOWED = new Set(ALLOWED_5_LIST.map(normWord));

    const cells = Array.from(document.querySelectorAll(".cell"));
    const keyEls = Array.from(document.querySelectorAll(".key"));
    const keyByChar = new Map(keyEls.map(k => [k.getAttribute("data-k"), k]));
    const msgEl = document.getElementById("msg");

    let row = 0;
    let col = 0;
    let isOver = false;
    let result = null; // "win" | "lose" | null

    const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(""));

   // Daily word selection (Europe/Bucharest midnight)
const START_KEY = "2025-01-01"; // season start (Bucharest date key)

function bucharestDateKey(now = new Date()) {
  const parts = new Intl.DateTimeFormat("en-CA", {
    timeZone: "Europe/Bucharest",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).formatToParts(now);

  const get = (type) => parts.find(p => p.type === type)?.value || "";
  const y = get("year");
  const m = get("month");
  const d = get("day");
  return `${y}-${m}-${d}`;
}

const todayKey = bucharestDateKey();
const puzzleIndex = Math.max(0, daysBetweenKeys(START_KEY, todayKey));
const ANSWER_RAW = ANSWERS_5[puzzleIndex % ANSWERS_5.length];
const ANSWER_NORM = normWord(ANSWER_RAW);
    const shareBtn = document.getElementById("shareBtn");
    // --- Save/restore (daily-only) ---
const STORAGE_KEY = `ritual_cinci_${todayKey}`;

function saveState() {
  const state = {
    todayKey,
    row,
    col,
    isOver,
    result,
    grid,
    keyState: Array.from(keyState.entries())
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function loadState() {
  // Remove any old saved days for CINCI
  for (let i = localStorage.length - 1; i >= 0; i--) {
    const k = localStorage.key(i);
    if (k && k.startsWith("ritual_cinci_") && k !== STORAGE_KEY) {
      localStorage.removeItem(k);
    }
  }

  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return false;

  try {
    const state = JSON.parse(raw);
    if (!state || state.todayKey !== todayKey) return false;

    row = state.row ?? 0;
    col = state.col ?? 0;
    isOver = !!state.isOver;
    result = state.result ?? null;

    // restore grid letters
    if (Array.isArray(state.grid) && state.grid.length === ROWS) {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = (state.grid[r] && state.grid[r][c]) ? state.grid[r][c] : "";
        }
      }
    }

    // restore keyboard states
    keyState.clear();
    if (Array.isArray(state.keyState)) {
      for (const [ch, st] of state.keyState) {
        keyState.set(ch, st);
      }
    }

    return true;
  } catch {
    return false;
  }
}

    function setMsg(text) { msgEl.textContent = text || ""; }
    function cellIndex(r, c) { return r * COLS + c; }

    function renderLetters() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const idx = cellIndex(r, c);
          cells[idx].textContent = grid[r][c];
          cells[idx].classList.toggle("filled", grid[r][c] !== "");
        }
      }
    }
   function renderKeyboardColors() {
  keyEls.forEach(k => k.classList.remove("absent","present","correct"));
  for (const [normCh, st] of keyState.entries()) {
    applyGroup(normCh, st);
  }
}

    function addLetter(ch) {
      if (isOver) return;
      if (row >= ROWS) return;
      if (col >= COLS) return;
      grid[row][col] = ch;
      col += 1;
      renderLetters();
      setMsg("");
      saveState();
    }

    function backspace() {
      if (isOver) return;
      if (row >= ROWS) return;
      if (col === 0) return;
      col -= 1;
      grid[row][col] = "";
      renderLetters();
      setMsg("");
      saveState();
    }

    function getCurrentGuess() {
      return grid[row].join("");
    }

    // Score with duplicate-letter handling
    function scoreGuess(guessNorm, answerNorm) {
      const states = Array(COLS).fill("absent");
      const ans = answerNorm.split("");
      const g = guessNorm.split("");

      // pass 1: correct
      for (let i = 0; i < COLS; i++) {
        if (g[i] === ans[i]) {
          states[i] = "correct";
          ans[i] = null;
          g[i] = null;
        }
      }
      // pass 2: present
      for (let i = 0; i < COLS; i++) {
        if (g[i] == null) continue;
        const idx = ans.indexOf(g[i]);
        if (idx !== -1) {
          states[i] = "present";
          ans[idx] = null;
        }
      }
      return states;
    }

    function paintRow(r, states) {
      for (let c = 0; c < COLS; c++) {
        const idx = cellIndex(r, c);
        cells[idx].classList.add(states[c]);
      }
    }

    // Keep keyboard coloring monotonic: correct > present > absent
    const rank = { absent: 1, present: 2, correct: 3 };
    // Key groups for HYBRID mode (color as a family)
const KEY_GROUPS = {
  A: ["A","ƒÇ","√Ç"],
  I: ["I","√é"],
  S: ["S","»ò"],
  T: ["T","»ö"]
};

function applyKeyClass(ch, st) {
  const el = keyByChar.get(ch);
  if (!el) return;
  el.classList.remove("absent","present","correct");
  el.classList.add(st);
}

function applyGroup(normCh, st) {
  const group = KEY_GROUPS[normCh] || [normCh];
  group.forEach(k => applyKeyClass(k, st));
}
    const keyState = new Map(); // char -> state

    function updateKeyboard(guessNorm, states) {
  for (let i = 0; i < guessNorm.length; i++) {
    const normCh = guessNorm[i];
    const st = states[i];

    const group = KEY_GROUPS[normCh] || [normCh];
    if (!group.some(k => keyByChar.has(k))) continue;

    const prev = keyState.get(normCh);
    if (!prev || rank[st] > rank[prev]) {
      keyState.set(normCh, st);
      applyGroup(normCh, st);
    }
  }
}

    function submitRow() {
      if (isOver) return;
      if (row >= ROWS) return;

      if (col < COLS) {
        setMsg("CompleteazƒÉ 5 litere.");
        return;
      }

      const guess = getCurrentGuess();

      if (!ALLOWED.has(guess)) {
        setMsg("Cuv√¢nt inexistent (lista v0).");
        return;
      }

      const states = scoreGuess(guess, ANSWER);
      paintRow(row, states);
      updateKeyboard(guess, states);
      saveState();

      if (guess === ANSWER) {
        isOver = true;
        result = "win";
        setMsg("Bravo. Ritual fƒÉcut ‚úÖ");
        saveState();
        return;
      }

      row += 1;
      col = 0;

      if (row >= ROWS) {
        isOver = true;
        result = "lose";
        setMsg(`Gata. Cuv√¢ntul era: ${ANSWER}`);
        saveState();
        return;
      }

      setMsg("");
    }

    function handleInputToken(token) {
      if (!token) return;
      if (token === "ENTER") return submitRow();
      if (token === "BACKSPACE") return backspace();

      const allowed = /^[A-ZƒÇ√Ç√é»ò»ö]$/;
      if (allowed.test(token)) addLetter(token);
    }

    // On-screen keyboard clicks
    keyEls.forEach(k => {
      k.addEventListener("click", () => {
        const t = k.getAttribute("data-k");
        handleInputToken(t);
      });
    });

    // Physical keyboard
    document.addEventListener("keydown", (e) => {
  // Don‚Äôt interfere with browser shortcuts (Ctrl/‚åò/Alt combos)
  if (e.ctrlKey || e.metaKey || e.altKey) return;

  if (e.key === "Enter") {
    e.preventDefault();
    return handleInputToken("ENTER");
  }
  if (e.key === "Backspace") {
    e.preventDefault();
    return handleInputToken("BACKSPACE");
  }

  // Romanian diacritics typed directly will work; other letters are uppercased
  const ch = (e.key || "").toUpperCase();

  // Only stop default behavior if it's a valid game letter
  if (/^[A-ZƒÇ√Ç√é»ò»ö]$/.test(ch)) {
    e.preventDefault();
    return handleInputToken(ch);
  }
});
// --- Share (copy result) ---
function emojiForState(st) {
  if (st === "correct") return "üü¶";
  if (st === "present") return "üü®";
  return "‚¨õ";
}

function buildShareText() {
  const solvedRow = grid.findIndex(r => r.join("") === ANSWER);
  const tries = solvedRow !== -1 ? `${solvedRow + 1}/6` : (isOver ? "X/6" : "-/6");

  const lines = [];
  lines.push(`Ritual ‚Äî CINCI ${todayKey} (${tries})`);

  const maxRow = isOver ? ROWS : row;
  for (let r = 0; r < maxRow; r++) {
    const guess = grid[r].join("");
    if (guess.length !== COLS) continue;
    const states = scoreGuess(guess, ANSWER);
    lines.push(states.map(emojiForState).join(""));
  }
  return lines.join("\n");
}

async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    setMsg("Copiat ‚úÖ");
  } catch {
    window.prompt("CopiazƒÉ manual:", text);
  }
}

if (shareBtn) {
  shareBtn.addEventListener("click", () => {
    copyToClipboard(buildShareText());
  });
}

  // Start (restore today's progress if it exists)
const restored = loadState();
renderLetters();

// If we restored, we need to re-apply colors.
// Easiest v0: re-score all completed rows and repaint.
if (restored) {
  for (let r = 0; r < ROWS; r++) {
    const guess = grid[r].join("");
    if (guess.length === COLS) {
      const states = scoreGuess(guess, ANSWER);
      paintRow(r, states);
      updateKeyboard(guess, states);
    }
  }
  renderKeyboardColors();
}

saveState();
  </script>
</body>
</html>
