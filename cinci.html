<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ritual ‚Äî CINCI</title>
  <style>
    :root{
      /* Ritual palette */
      --correct: #7CB8FF;  /* baby blue */
      --present: #F2C14E;  /* honey/sand */
      --absent:  #8B9098;  /* cool stone gray */
      --ink:     #0B1F33;  /* dark navy */
    }

    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { max-width: 760px; margin: 0 auto; padding: 22px 16px 40px; }
    a { color: inherit; }
    .top { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .brand { font-weight: 700; letter-spacing: .2px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; background:#f3f3f3; font-size: 13px; }
    h1 { font-size: 28px; margin: 14px 0 6px; }
    p { margin: 0 0 12px; color:#333; }
    .hr { height:1px; background:#eee; margin: 16px 0 14px; }

    .board { margin: 18px auto 16px; width: min(360px, 100%); display:grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
    .cell {
      height: 54px; border: 2px solid #ddd; border-radius: 10px;
      display:flex; align-items:center; justify-content:center;
      font-size: 22px; font-weight: 700;
      user-select: none;
    }
    .cell.filled { border-color: #bbb; }
    .cell.correct { background: var(--correct); border-color: var(--correct); color: var(--ink); }
    .cell.present { background: var(--present); border-color: var(--present); color: var(--ink); }
    .cell.absent  { background: var(--absent);  border-color: var(--absent);  color: #fff; }

    .keyboard { width: min(760px, 100%); margin: 12px auto 0; display:flex; flex-direction:column; gap: 8px; }
    .row { display:flex; gap: 6px; justify-content:center; flex-wrap: nowrap; }
    .key {
      border: 1px solid #ddd; border-radius: 10px; background:#fff;
      padding: 12px 10px; min-width: 34px; text-align:center;
      font-weight: 600; cursor: pointer; user-select: none;
    }
    .key:hover { border-color: #bbb; }
    .key.wide { min-width: 68px; }

    /* Keyboard state colors (same as tiles) */
    .key.correct { background: var(--correct); border-color: var(--correct); color: var(--ink); }
    .key.present { background: var(--present); border-color: var(--present); color: var(--ink); }
    .key.absent  { background: var(--absent);  border-color: var(--absent);  color: #fff; }

    .hint { font-size: 13px; color:#666; margin-top: 10px; min-height: 18px; text-align:center; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">Ritual</div>
      <div class="pill">CINCI</div>
      <div><a href="./index.html">√énapoi</a></div>
    </div>

    <h1>CINCI</h1>
    <p>Ghice»ôte cuv√¢ntul zilei √Æn 6 √ÆncercƒÉri.</p>
    <div class="hr"></div>

    <!-- Board: 6 rows x 5 cells -->
    <div class="board" aria-label="Tabla de joc">
      <!-- Row 1 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 2 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 3 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 4 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 5 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
      <!-- Row 6 -->
      <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
    </div>

    <div class="keyboard" aria-label="TastaturƒÉ">
      <div class="row">
        <div class="key" data-k="Q">Q</div><div class="key" data-k="W">W</div><div class="key" data-k="E">E</div><div class="key" data-k="R">R</div><div class="key" data-k="T">T</div>
        <div class="key" data-k="Y">Y</div><div class="key" data-k="U">U</div><div class="key" data-k="I">I</div><div class="key" data-k="O">O</div><div class="key" data-k="P">P</div>
      </div>
      <div class="row">
        <div class="key" data-k="A">A</div><div class="key" data-k="S">S</div><div class="key" data-k="D">D</div><div class="key" data-k="F">F</div><div class="key" data-k="G">G</div>
        <div class="key" data-k="H">H</div><div class="key" data-k="J">J</div><div class="key" data-k="K">K</div><div class="key" data-k="L">L</div>
        <div class="key" data-k="ƒÇ">ƒÇ</div><div class="key" data-k="√Ç">√Ç</div><div class="key" data-k="√é">√é</div>
      </div>
      <div class="row">
        <div class="key wide" data-k="ENTER">Enter</div>
        <div class="key" data-k="Z">Z</div><div class="key" data-k="X">X</div><div class="key" data-k="C">C</div><div class="key" data-k="V">V</div><div class="key" data-k="B">B</div>
        <div class="key" data-k="N">N</div><div class="key" data-k="M">M</div>
        <div class="key" data-k="»ò">»ò</div><div class="key" data-k="»ö">»ö</div>
        <div class="key wide" data-k="BACKSPACE">‚Üê</div>
      </div>
    </div>

    <div style="display:flex; gap:10px; justify-content:center; align-items:center; margin-top:10px;">
  <button id="shareBtn" style="border:1px solid #ddd; border-radius:10px; background:#fff; padding:10px 12px; font-weight:600; cursor:pointer;">
    CopiazƒÉ
  </button>
  <div id="msg" class="hint" style="margin:0;">ApasƒÉ tastele sau scrie de la tastaturƒÉ.</div>
</div>
  </div>

  <script>
    // --- CINCI (daily-only, v0 word list) ---
    const ROWS = 6;
    const COLS = 5;

    // v0 test words (5 letters, uppercase). We'll expand later.
    const WORDS = [
      "CARTE","MASIV","NOROC","PIESE","SALTA",
      "MUNTE","LACUL","ROATA","LUMEA","COPAC",
      "FEREA","SOARE","NODUL","VIRUS","LINIE",
      "PUNCT","HARTA","SAREI","CINCI","ALTAR"
    ].map(w => w.toUpperCase());

    const ALLOWED = new Set(WORDS);

    const cells = Array.from(document.querySelectorAll(".cell"));
    const keyEls = Array.from(document.querySelectorAll(".key"));
    const keyByChar = new Map(keyEls.map(k => [k.getAttribute("data-k"), k]));
    const msgEl = document.getElementById("msg");

    let row = 0;
    let col = 0;
    let isOver = false;
    let result = null; // "win" | "lose" | null

    const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(""));

   // Daily word selection (Europe/Bucharest midnight)
const START_KEY = "2025-01-01"; // season start (Bucharest date key)

function bucharestDateKey(now = new Date()) {
  // en-CA gives YYYY-MM-DD formatting, with timeZone forced to Europe/Bucharest
  return new Intl.DateTimeFormat("en-CA", {
    timeZone: "Europe/Bucharest",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).format(now);
}

function daysBetweenKeys(startKey, endKey) {
  // startKey/endKey are "YYYY-MM-DD"
  const [sy, sm, sd] = startKey.split("-").map(Number);
  const [ey, em, ed] = endKey.split("-").map(Number);
  const startUTC = Date.UTC(sy, sm - 1, sd);
  const endUTC = Date.UTC(ey, em - 1, ed);
  const msPerDay = 24 * 60 * 60 * 1000;
  return Math.floor((endUTC - startUTC) / msPerDay);
}

const todayKey = bucharestDateKey();
const puzzleIndex = Math.max(0, daysBetweenKeys(START_KEY, todayKey));
const ANSWER = WORDS[puzzleIndex % WORDS.length];
    const shareBtn = document.getElementById("shareBtn");
    // --- Save/restore (daily-only) ---
const STORAGE_KEY = `ritual_cinci_${todayKey}`;

function saveState() {
  const state = {
    todayKey,
    row,
    col,
    isOver,
    result,
    grid,
    keyState: Array.from(keyState.entries())
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function loadState() {
  // Remove any old saved days for CINCI
  for (let i = localStorage.length - 1; i >= 0; i--) {
    const k = localStorage.key(i);
    if (k && k.startsWith("ritual_cinci_") && k !== STORAGE_KEY) {
      localStorage.removeItem(k);
    }
  }

  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return false;

  try {
    const state = JSON.parse(raw);
    if (!state || state.todayKey !== todayKey) return false;

    row = state.row ?? 0;
    col = state.col ?? 0;
    isOver = !!state.isOver;
    result = state.result ?? null;

    // restore grid letters
    if (Array.isArray(state.grid) && state.grid.length === ROWS) {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          grid[r][c] = (state.grid[r] && state.grid[r][c]) ? state.grid[r][c] : "";
        }
      }
    }

    // restore keyboard states
    keyState.clear();
    if (Array.isArray(state.keyState)) {
      for (const [ch, st] of state.keyState) {
        keyState.set(ch, st);
      }
    }

    return true;
  } catch {
    return false;
  }
}

    function setMsg(text) { msgEl.textContent = text || ""; }
    function cellIndex(r, c) { return r * COLS + c; }

    function renderLetters() {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const idx = cellIndex(r, c);
          cells[idx].textContent = grid[r][c];
          cells[idx].classList.toggle("filled", grid[r][c] !== "");
        }
      }
    }
    function renderKeyboardColors() {
  keyEls.forEach(k => k.classList.remove("absent","present","correct"));
  for (const [ch, st] of keyState.entries()) {
    const el = keyByChar.get(ch);
    if (!el) continue;
    el.classList.add(st);
  }
}

    function addLetter(ch) {
      if (isOver) return;
      if (row >= ROWS) return;
      if (col >= COLS) return;
      grid[row][col] = ch;
      col += 1;
      renderLetters();
      setMsg("");
      saveState();
    }

    function backspace() {
      if (isOver) return;
      if (row >= ROWS) return;
      if (col === 0) return;
      col -= 1;
      grid[row][col] = "";
      renderLetters();
      setMsg("");
      saveState();
    }

    function getCurrentGuess() {
      return grid[row].join("");
    }

    // Score with duplicate-letter handling
    function scoreGuess(guess, answer) {
      const states = Array(COLS).fill("absent");
      const ans = answer.split("");
      const g = guess.split("");

      // pass 1: correct
      for (let i = 0; i < COLS; i++) {
        if (g[i] === ans[i]) {
          states[i] = "correct";
          ans[i] = null;
          g[i] = null;
        }
      }
      // pass 2: present
      for (let i = 0; i < COLS; i++) {
        if (g[i] == null) continue;
        const idx = ans.indexOf(g[i]);
        if (idx !== -1) {
          states[i] = "present";
          ans[idx] = null;
        }
      }
      return states;
    }

    function paintRow(r, states) {
      for (let c = 0; c < COLS; c++) {
        const idx = cellIndex(r, c);
        cells[idx].classList.add(states[c]);
      }
    }

    // Keep keyboard coloring monotonic: correct > present > absent
    const rank = { absent: 1, present: 2, correct: 3 };
    const keyState = new Map(); // char -> state

    function updateKeyboard(guess, states) {
      for (let i = 0; i < guess.length; i++) {
        const ch = guess[i];
        const st = states[i];
        if (!keyByChar.has(ch)) continue;

        const prev = keyState.get(ch);
        if (!prev || rank[st] > rank[prev]) {
          keyState.set(ch, st);
          const el = keyByChar.get(ch);
          el.classList.remove("absent","present","correct");
          el.classList.add(st);
        }
      }
    }

    function submitRow() {
      if (isOver) return;
      if (row >= ROWS) return;

      if (col < COLS) {
        setMsg("CompleteazƒÉ 5 litere.");
        return;
      }

      const guess = getCurrentGuess();

      if (!ALLOWED.has(guess)) {
        setMsg("Cuv√¢nt inexistent (lista v0).");
        return;
      }

      const states = scoreGuess(guess, ANSWER);
      paintRow(row, states);
      updateKeyboard(guess, states);
      saveState();

      if (guess === ANSWER) {
        isOver = true;
        result = "win";
        setMsg("Bravo. Ritual fƒÉcut ‚úÖ");
        saveState();
        return;
      }

      row += 1;
      col = 0;

      if (row >= ROWS) {
        isOver = true;
        result = "lose";
        setMsg(`Gata. Cuv√¢ntul era: ${ANSWER}`);
        saveState();
        return;
      }

      setMsg("");
    }

    function handleInputToken(token) {
      if (!token) return;
      if (token === "ENTER") return submitRow();
      if (token === "BACKSPACE") return backspace();

      const allowed = /^[A-ZƒÇ√Ç√é»ò»ö]$/;
      if (allowed.test(token)) addLetter(token);
    }

    // On-screen keyboard clicks
    keyEls.forEach(k => {
      k.addEventListener("click", () => {
        const t = k.getAttribute("data-k");
        handleInputToken(t);
      });
    });

    // Physical keyboard
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter") return handleInputToken("ENTER");
      if (e.key === "Backspace") return handleInputToken("BACKSPACE");

      // Romanian diacritics typed directly will work; other letters are uppercased
      const ch = (e.key || "").toUpperCase();
      handleInputToken(ch);
    });

   // Start (restore today's progress if it exists)
const restored = loadState();
renderLetters();

// If we restored, we need to re-apply colors.
// Easiest v0: re-score all completed rows and repaint.
if (restored) {
  for (let r = 0; r < ROWS; r++) {
    const guess = grid[r].join("");
    if (guess.length === COLS) {
      const states = scoreGuess(guess, ANSWER);
      paintRow(r, states);
      updateKeyboard(guess, states);
    }
  }
  renderKeyboardColors();
  
}
saveState();

}
saveState();
    function emojiForState(st) {
  if (st === "correct") return "üü¶";  // baby blue
  if (st === "present") return "üü®";  // honey
  return "‚¨õ";                         // stone/absent
}

function buildShareText() {
  const lines = [];
 const tries = result === "win" ? `${row + 1}/6` : (result === "lose" ? "X/6" : "-/6");
lines.push(`Ritual ‚Äî CINCI ${todayKey} (${tries})`);

  // For each completed row up to current row (or all rows if game over)
  const maxRow = isOver ? ROWS : row;
  for (let r = 0; r < maxRow; r++) {
    const guess = grid[r].join("");
    if (guess.length !== COLS) continue;
    const states = scoreGuess(guess, ANSWER);
    lines.push(states.map(emojiForState).join(""));
  }
  return lines.join("\n");
}

async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    setMsg("Copiat ‚úÖ");
  } catch {
    // Fallback: prompt (works even if clipboard permissions are blocked)
    window.prompt("CopiazƒÉ manual:", text);
  }
}

    shareBtn.addEventListener("click", () => {
  const text = buildShareText();
  copyToClipboard(text);
});
  </script>
</body>
</html>
